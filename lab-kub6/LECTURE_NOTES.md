# Лекция 6: Почему распределённое состояние — самая сложная часть системы

## Ключевая идея
В Kubernetes pod-ы эфемерны, поэтому хранить важное состояние «в памяти pod-а» нельзя как постоянную стратегию.

## Почему обычный подход не подходит
- Pod перезапускается и теряет локальное состояние.
- Pod удаляется/заменяется при обновлении и авто-восстановлении.
- Количество pod-ов динамически меняется.

## Cluster Sharding (интуитивно)
- состояние хранится в entity-акторах;
- entity автоматически распределяются по shard-ам и узлам;
- размещением и восстановлением управляет Akka, а не клиентский код.

## Термины
- `Entity`: бизнес-сущность (например, `AccountActor(user-42)`).
- `Shard`: группа entity, техническая единица распределения.

## Почему entity нельзя создавать вручную
Ручное создание ломает распределённость: клиенту приходится знать узел/адрес, что противоречит динамике Kubernetes.

## Жизненный цикл entity
1. Приходит сообщение с `entityId`.
2. Если entity отсутствует — создаётся автоматически.
3. Обрабатывает сообщения последовательно.
4. Может быть пассивирована при простое.
5. При новом сообщении создаётся снова.

## Что даёт Cluster Sharding
- одна entity = один актор в кластере;
- последовательная обработка сообщений в рамках entity;
- перенос и восстановление при изменениях кластера;
- прозрачность для клиента через `EntityRef`.

## В этой лабораторной
- Реализован `AccountActor` с балансом;
- Подключен `akka-cluster-sharding-typed`;
- Инициализирован sharding в `Main`;
- Развертывание выполнено для Kubernetes.
